{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/IERC20withDecimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// FORK OF OPPENZEPPLIN IERC20 CONTRACT WITH THE ADDED DECIMALS FUNCTION\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20withDecimals {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n\r\n    function decimals() external view returns (uint8);\r\n     \r\n}"
    },
    "contracts/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n\tstruct ExactInputSingleParams {\r\n\t\taddress tokenIn;\r\n\t\taddress tokenOut;\r\n\t\tuint24 fee;\r\n\t\taddress recipient;\r\n\t\tuint256 amountIn;\r\n\t\tuint256 amountOutMinimum;\r\n\t\tuint160 sqrtPriceLimitX96;\r\n\t}\r\n\r\n\t/// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n\t/// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n\t/// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n\t/// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n\t/// @return amountOut The amount of the received token\r\n\tfunction exactInputSingle(\r\n\t\tExactInputSingleParams calldata params\r\n\t) external payable returns (uint256 amountOut);\r\n\r\n\tstruct ExactInputParams {\r\n\t\tbytes path;\r\n\t\taddress recipient;\r\n\t\tuint256 amountIn;\r\n\t\tuint256 amountOutMinimum;\r\n\t}\r\n\r\n\t/// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n\t/// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n\t/// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n\t/// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n\t/// @return amountOut The amount of the received token\r\n\tfunction exactInput(\r\n\t\tExactInputParams calldata params\r\n\t) external payable returns (uint256 amountOut);\r\n\r\n\tstruct ExactOutputSingleParams {\r\n\t\taddress tokenIn;\r\n\t\taddress tokenOut;\r\n\t\tuint24 fee;\r\n\t\taddress recipient;\r\n\t\tuint256 amountOut;\r\n\t\tuint256 amountInMaximum;\r\n\t\tuint160 sqrtPriceLimitX96;\r\n\t}\r\n\r\n\t/// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n\t/// that may remain in the router after the swap.\r\n\t/// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n\t/// @return amountIn The amount of the input token\r\n\tfunction exactOutputSingle(\r\n\t\tExactOutputSingleParams calldata params\r\n\t) external payable returns (uint256 amountIn);\r\n\r\n\tstruct ExactOutputParams {\r\n\t\tbytes path;\r\n\t\taddress recipient;\r\n\t\tuint256 amountOut;\r\n\t\tuint256 amountInMaximum;\r\n\t}\r\n\r\n\t/// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n\t/// that may remain in the router after the swap.\r\n\t/// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n\t/// @return amountIn The amount of the input token\r\n\tfunction exactOutput(\r\n\t\tExactOutputParams calldata params\r\n\t) external payable returns (uint256 amountIn);\r\n}\r\n"
    },
    "contracts/ITrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface ITrailMix {\r\n\tfunction deposit(uint256 amount, uint256 tslThreshold) external;\r\n\r\n\tfunction withdraw(address token) external;\r\n\r\n\tfunction checkUpkeepNeeded()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool, bool, bool, uint256);\r\n\r\n\tfunction updateTSLThreshold(uint256 newThreshold) external;\r\n\r\n\tfunction getEthUsdPrice() external view returns (uint256);\r\n\r\n\tfunction getTwapPrice() external view returns (uint256);\r\n\r\n\tfunction getExactPrice(address token) external view returns (uint256);\r\n\r\n\tfunction swapOnUniswap(\r\n\t\taddress tokenIn,\r\n\t\taddress tokenOut,\r\n\t\tuint256 amount\r\n\t) external returns (uint256);\r\n\r\n\tfunction executeTSL() external;\r\n\r\n\tfunction executeLimitBuy() external;\r\n\r\n\tfunction toggleSlippageProtection() external;\r\n\r\n\tfunction getERC20Balance() external view returns (uint256);\r\n\r\n\tfunction getStablecoinBalance() external view returns (uint256);\r\n\r\n\tfunction getTSLThreshold() external view returns (uint256);\r\n\r\n\tfunction getERC20TokenAddress() external view returns (address);\r\n\r\n\tfunction getStablecoinAddress() external view returns (address);\r\n\r\n\tfunction getUniswapRouterAddress() external view returns (address);\r\n\r\n\tfunction getTrailAmount() external view returns (uint256);\r\n\r\n\tfunction getManager() external view returns (address);\r\n\r\n\tfunction getCreator() external view returns (address);\r\n\r\n\tfunction getGranularity() external view returns (uint256);\r\n\r\n\tfunction getUniswapPool() external view returns (address);\r\n\r\n\tfunction getDepositValue() external view returns (uint256);\r\n\r\n\tfunction getState() external view returns (string memory);\r\n}\r\n"
    },
    "contracts/IUniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IUniswapOracle {\r\n    function estimateAmountOut(\r\n        address pool,\r\n        address tokenIn,\r\n        uint128 amountIn,\r\n        uint32 secondsAgo\r\n    ) external view returns (uint amountOut);\r\n}\r\n"
    },
    "contracts/TrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport { ISwapRouter } from \"./ISwapRouter.sol\";\nimport { IERC20withDecimals } from \"./IERC20withDecimals.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IUniswapOracle } from \"./IUniswapOracle.sol\";\n\nerror InvalidAmount(); // Error for when the deposit amount is not positive\nerror TransferFailed(); // Error for when the token transfer fails\nerror InvalidToken(); // Error for when the token address is invalid\nerror StrategyNotActive();\n\n//events are emitted in the manager contract\ncontract TrailMix is ReentrancyGuard {\n\taddress private immutable i_manager; //address of the manager contract\n\taddress private immutable i_creator; // address of the creator of the contract\n\n\taddress private s_erc20Token;\n\taddress private s_stablecoin;\n\n\tISwapRouter private s_uniswapRouter;\n\taddress public immutable s_uniswapPool;\n\tIUniswapOracle private s_uniswapOracle; // TWAP oracle for Uniswap V3\n\n\tuint256 private immutable s_trailAmount; // Amount to trail by as a %\n\tuint256 private s_tslThreshold; // User's TSL threshold\n\tuint256 private s_erc20Balance;\n\tuint256 private s_stablecoinBalance; // User's ERC20 token balance\n\tuint256 private s_granularity; //  % price increase to trigger an update\n\tbool private slippageProtection; // Indicates if slippage protection is enabled\n\tuint24 private s_poolFee;\n\n\t//USED FOR PROFIT TRACKING\n\tuint256 private s_depositValue; // Value of the deposit in USD\n\tuint8 private s_stablecoinDecimals; //number of decimals the stablecoin has\n\tuint8 private s_erc20TokenDecimals;\n\n\tAggregatorV3Interface private s_ethUsdPriceFeed;\n\tbool private s_wethPair; //indicates if the pair is against WETH or USD\n\t// if against weth then we will use the eth price feed to calculate the price of the asset in usd\n\n\tuint256 private s_limitBuyPrice;\n\tuint256 private s_limitDelay; // how long the before the limit order will be placed\n\n\t//stores current state of contract\n\tenum ContractState {\n\t\tUninitialized,\n\t\tTrailingStop,\n\t\tLimitBuy,\n\t\tInactive\n\t}\n\tContractState private state;\n\n\tconstructor(\n\t\taddress _manager,\n\t\taddress _creator,\n\t\taddress _erc20Token,\n\t\taddress _stablecoin,\n\t\taddress _uniswapRouter,\n\t\taddress _uniswapPool,\n\t\taddress _uniswapOracle,\n\t\tuint256 _trailAmount,\n\t\tuint256 granularity,\n\t\tuint24 _poolFee,\n\t\taddress _ethUsdPriceFeed,\n\t\tbool _wethPair\n\t) {\n\t\ti_manager = _manager;\n\t\ti_creator = _creator;\n\n\t\ts_erc20Token = _erc20Token;\n\t\ts_stablecoin = _stablecoin;\n\n\t\ts_uniswapRouter = ISwapRouter(_uniswapRouter);\n\t\ts_uniswapOracle = IUniswapOracle(_uniswapOracle);\n\t\ts_uniswapPool = _uniswapPool;\n\n\t\ts_trailAmount = _trailAmount;\n\t\tslippageProtection = true;\n\t\ts_granularity = granularity;\n\t\ts_poolFee = _poolFee;\n\t\tstate = ContractState.Uninitialized;\n\t\ts_stablecoinDecimals = IERC20withDecimals(_stablecoin).decimals();\n\t\ts_erc20TokenDecimals = IERC20withDecimals(_erc20Token).decimals();\n\t\ts_ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);\n\n\t\ts_wethPair = _wethPair;\n\t}\n\n\tmodifier onlyManager() {\n\t\trequire(msg.sender == i_manager, \"only callable by manager contract\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Deposits a specified amount of the ERC20 token into the contract.\n\t * @param amount The amount of the ERC20 token to deposit.\n\t * @param tslThreshold The initial trailing stop loss threshold as a percentage.\n\t */\n\tfunction deposit(uint256 amount, uint256 tslThreshold) external {\n\t\tif (amount <= 0) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\t\tif (state == ContractState.Inactive) {\n\t\t\trevert StrategyNotActive();\n\t\t}\n\n\t\tbool transferSuccess = IERC20withDecimals(s_erc20Token).transferFrom(\n\t\t\t// i_manager,\n\t\t\tmsg.sender, //for testing purposes\n\t\t\taddress(this),\n\t\t\tamount\n\t\t);\n\t\tif (!transferSuccess) {\n\t\t\trevert TransferFailed();\n\t\t}\n\n\t\ts_erc20Balance += amount;\n\n\t\tif (state == ContractState.Uninitialized) {\n\t\t\t// If TSL is not active, set the threshold and activate TSL\n\t\t\ts_tslThreshold = (tslThreshold * (100 - s_trailAmount)) / 100;\n\n\t\t\tstate = ContractState.TrailingStop;\n\t\t}\n\n\t\t//store usd value at time of deposit\n\t\ts_depositValue += getTwapPrice() * amount;\n\t}\n\n\t/**\n\t * @notice Withdraws the user's funds from the contract.\n\t * @dev Allows withdrawal of either ERC20 tokens or stablecoins\n\t */\n\tfunction withdraw(address token) external {\n\t\tuint256 withdrawalAmount;\n\n\t\tif (token == s_stablecoin) {\n\t\t\t// Logic to handle stablecoin withdrawal\n\t\t\twithdrawalAmount = s_stablecoinBalance;\n\t\t\tif (withdrawalAmount <= 0) {\n\t\t\t\trevert InvalidAmount();\n\t\t\t}\n\t\t\ts_stablecoinBalance = 0;\n\t\t\tTransferHelper.safeTransfer(\n\t\t\t\ts_stablecoin,\n\t\t\t\ti_creator, // sends funds to the contract creator\n\t\t\t\twithdrawalAmount\n\t\t\t);\n\t\t\t//deactiveate TSL\n\t\t\tstate = ContractState.Inactive;\n\t\t} else if (token == s_erc20Token) {\n\t\t\t// If TSL is active, user withdraws their ERC20 tokens\n\t\t\twithdrawalAmount = s_erc20Balance;\n\t\t\tif (withdrawalAmount <= 0) {\n\t\t\t\trevert InvalidAmount();\n\t\t\t}\n\t\t\ts_erc20Balance = 0;\n\t\t\tTransferHelper.safeTransfer(\n\t\t\t\ts_erc20Token,\n\t\t\t\ti_creator,\n\t\t\t\twithdrawalAmount\n\t\t\t);\n\t\t\t//deactivate tsl\n\t\t\tstate = ContractState.Inactive;\n\t\t} else {\n\t\t\trevert InvalidToken();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Checks if upkeep is needed based on TSL conditions.\n\t * @return A tuple of four values: a boolean indicating if limit buy should be triggered, a boolean indicating if tsl should be triggered, a boolean indicating if the threshold should be updated, and the new threshold value.\n\t */\n\tfunction checkUpkeepNeeded()\n\t\texternal\n\t\tview\n\t\treturns (bool, bool, bool, uint256)\n\t{\n\t\t// If contract is in trailing stop state then check if it needs to be updated or executed\n\t\tif (state == ContractState.TrailingStop) {\n\t\t\tuint256 currentPrice = getTwapPrice();\n\t\t\tuint256 exactPrice = getExactPrice(s_erc20Token);\n\n\t\t\tbool triggerSell = false;\n\t\t\tbool updateThreshold = false;\n\t\t\tuint256 newThreshold = 0;\n\n\t\t\t// Calculate 10% price range bounds\n\t\t\tuint256 lowerBound = (currentPrice * 90) / 100;\n\t\t\tuint256 upperBound = (currentPrice * 110) / 100;\n\t\t\t//calculates the old all time high price based on the threshold\n\t\t\tuint256 oldCurrentPrice = (s_tslThreshold * 100) /\n\t\t\t\t(100 - s_trailAmount);\n\n\t\t\t//determines the price that is granularity% higher than the old stored price\n\t\t\tuint256 minPriceForUpdate = (oldCurrentPrice *\n\t\t\t\t(100 + s_granularity)) / 100;\n\t\t\t//if new price is less than the current threshold then trigger TSL\n\t\t\tif (exactPrice >= lowerBound && exactPrice <= upperBound) {\n\t\t\t\tif (currentPrice < s_tslThreshold) {\n\t\t\t\t\t//trigger TSL\n\t\t\t\t\ttriggerSell = true;\n\t\t\t\t} else if (currentPrice > minPriceForUpdate) {\n\t\t\t\t\tupdateThreshold = true;\n\t\t\t\t\tnewThreshold = (currentPrice * (100 - s_trailAmount)) / 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (false, triggerSell, updateThreshold, newThreshold);\n\t\t} else if (state == ContractState.LimitBuy) {\n\t\t\tuint256 currentPrice = getTwapPrice();\n\t\t\tbool limitTrigger = false;\n\t\t\tif (\n\t\t\t\tcurrentPrice < s_limitBuyPrice && block.timestamp > s_limitDelay\n\t\t\t) {\n\t\t\t\tlimitTrigger = true;\n\t\t\t}\n\n\t\t\treturn (limitTrigger, false, false, 0);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Updates the trailing stop loss threshold.\n\t * @dev This function is private and should be called only by performUpkeep.\n\t * @param newThreshold The new threshold value to set.\n\t */\n\tfunction updateTSLThreshold(uint256 newThreshold) external {\n\t\ts_tslThreshold = newThreshold;\n\t}\n\n\tfunction getEthUsdPrice() public view returns (uint256) {\n\t\t(\n\t\t\t,\n\t\t\t/* uint80 roundID */ int256 price /* uint startedAt */ /* uint timeStamp */ /* uint80 answeredInRound */,\n\t\t\t,\n\t\t\t,\n\n\t\t) = s_ethUsdPriceFeed.latestRoundData();\n\t\tuint8 decimals = s_ethUsdPriceFeed.decimals();\n\t\treturn uint256(price) * (10 ** (18 - decimals)); // standardizes price to 18 decimals\n\t}\n\n\t/**\n\t * @notice Gets the latest price of the ERC20 token in USD. Only used for triggering upkeep actions\n\t * @dev Uses the Uniswap Oracle to get the latest price using TWAP (time-weighted average price) data for the past 5 minutes.\n\t * Uses Chainlink's price feed to fetch eth price\n\t * @return The latest price of the ERC20 token in stablecoins.\n\t */\n\tfunction getTwapPrice() public view returns (uint256) {\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\n\t\t\ts_uniswapPool,\n\t\t\ts_erc20Token,\n\t\t\t1e18, // number of decimals for erc20 token\n\t\t\t300 // 5 minutes of price data (300 seconds)\n\t\t);\n\t\tif (s_wethPair) {\n\t\t\tuint256 ethPrice = getEthUsdPrice();\n\t\t\treturn (amountOut * ethPrice) / 10 ** 18;\n\t\t}\n\t\treturn amountOut;\n\t}\n\n\t/**\n\t * @notice Gets the exact price of the ERC20 token in its paired asset. Used for calculating swap parameters.\n\t * @dev gets price at the current block timestamp of asset in reference to its paired asset\n\t * @return The latest price of the ERC20 token in reference to its paired asset.\n\t */\n\tfunction getExactPrice(address token) public view returns (uint256) {\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\n\t\t\ts_uniswapPool,\n\t\t\ttoken,\n\t\t\t1e18, // number of decimals for erc20 token\n\t\t\t1\n\t\t);\n\n\t\treturn amountOut;\n\t}\n\n\t/**\n\t * @notice Swaps the user's ERC20 tokens for stablecoins on Uniswap.\n\t * @dev only callable by the manager contract. Non-reentrant.\n\t * @param amount The amount of the ERC20 token to swap.\n\t */\n\tfunction swapOnUniswap(\n\t\taddress tokenIn,\n\t\taddress tokenOut,\n\t\tuint256 amount\n\t) private returns (uint256) {\n\t\t//swap ERC20 tokens for stablecoin on uniswap\n\t\t//need to approve uniswap to spend ERC20 tokens\n\n\t\t//gets the most up to date price to calculate slippage\n\t\tuint256 currentPrice = getExactPrice(tokenIn);\n\t\tuint256 minAmountOut;\n\n\t\tuint256 feeBps = s_poolFee; //take into account the pool fees\n\n\t\tif (slippageProtection) {\n\t\t\tminAmountOut =\n\t\t\t\t(amount * currentPrice * (feeBps + 500)) /\n\t\t\t\t(100000 * 1e18); //99.5% of the current price (including pool fee)\n\t\t} else {\n\t\t\tminAmountOut = 0;\n\t\t}\n\n\t\tIERC20withDecimals(tokenIn).approve(\n\t\t\taddress(s_uniswapRouter),\n\t\t\tamount\n\t\t);\n\n\t\tISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n\t\t\t.ExactInputSingleParams({\n\t\t\t\ttokenIn: tokenIn,\n\t\t\t\ttokenOut: tokenOut,\n\t\t\t\tfee: s_poolFee,\n\t\t\t\trecipient: address(this),\n\t\t\t\t// deadline: block.timestamp, NOT NEEDED FOR ROUTER ON BASE\n\t\t\t\tamountIn: amount,\n\t\t\t\tamountOutMinimum: minAmountOut,\n\t\t\t\tsqrtPriceLimitX96: 0\n\t\t\t});\n\t\tuint256 amountOut = s_uniswapRouter.exactInputSingle(params);\n\n\t\t//TRACK BALANCE OF STABLECOIN AND BASE TOKEN IN CONTRACT\n\t\tif (tokenIn == s_stablecoin) {\n\t\t\ts_erc20Balance += amountOut;\n\t\t\ts_stablecoinBalance = 0;\n\t\t} else {\n\t\t\ts_stablecoinBalance += amountOut;\n\t\t\ts_erc20Balance =0;\n\t\t}\n\t\treturn amountOut;\n\t}\n\n\t/**\n\t * @notice Swaps asset into stable token on Uniswap and sets the contract into the buying state.\n\t * @dev only callable by the manager contract. Non-reentrant.\n\t */\n\tfunction executeTSL() external {\n\t\trequire(\n\t\t\tstate == ContractState.TrailingStop,\n\t\t\t\"Not in TrailingStop state\"\n\t\t);\n\t\tuint256 amountOut = swapOnUniswap(\n\t\t\ts_erc20Token,\n\t\t\ts_stablecoin,\n\t\t\ts_erc20Balance\n\t\t);\n\n\t\ts_limitBuyPrice = getExactPrice(s_erc20Token); // price that the erc20 token was sold at\n\n\t\ts_limitDelay = block.timestamp + 1 days; //set the limit order to be placed in 1 day\n\t\tstate = ContractState.LimitBuy;\n\t}\n\n\tfunction executeLimitBuy() external {\n\t\trequire(state == ContractState.LimitBuy, \"Not in LimitBuy state\");\n\t\tuint256 amountOut = swapOnUniswap(\n\t\t\ts_stablecoin,\n\t\t\ts_erc20Token,\n\t\t\ts_stablecoinBalance\n\t\t);\n\n\t\tuint256 currentPrice = getTwapPrice();\n\t\ts_tslThreshold = (currentPrice * (100 - s_trailAmount)) / 100;\n\n\t\t//reset limit order parameters\n\t\ts_limitBuyPrice = 0;\n\n\t\tstate = ContractState.TrailingStop;\n\t}\n\n\t/**\n\t * @notice Activates slippage protection for token swaps.\n\t * @dev Can only be called by the contract owner.\n\t */\n\tfunction toggleSlippageProtection() public onlyManager {\n\t\tslippageProtection = !slippageProtection;\n\t}\n\n\t// View functions for contract interaction and frontend integration\n\tfunction getERC20Balance() public view returns (uint256) {\n\t\treturn s_erc20Balance;\n\t}\n\n\tfunction getStablecoinBalance() public view returns (uint256) {\n\t\treturn s_stablecoinBalance;\n\t}\n\n\tfunction getTSLThreshold() public view returns (uint256) {\n\t\treturn s_tslThreshold;\n\t}\n\n\t// View function to get ERC20 token address\n\tfunction getERC20TokenAddress() public view returns (address) {\n\t\treturn s_erc20Token;\n\t}\n\n\t// View function to get stablecoin address\n\tfunction getStablecoinAddress() public view returns (address) {\n\t\treturn s_stablecoin;\n\t}\n\n\t// View function to get Uniswap router address\n\tfunction getUniswapRouterAddress() public view returns (address) {\n\t\treturn address(s_uniswapRouter);\n\t}\n\n\tfunction getTrailAmount() public view returns (uint256) {\n\t\treturn s_trailAmount;\n\t}\n\n\tfunction getManager() public view returns (address) {\n\t\treturn i_manager;\n\t}\n\n\tfunction getCreator() public view returns (address) {\n\t\treturn i_creator;\n\t}\n\n\tfunction getGranularity() public view returns (uint256) {\n\t\treturn s_granularity;\n\t}\n\n\tfunction getUniswapPool() public view returns (address) {\n\t\treturn s_uniswapPool;\n\t}\n\n\tfunction getDepositValue() public view returns (uint256) {\n\t\treturn s_depositValue;\n\t}\n\n\tfunction getState() public view returns (string memory) {\n\t\tif (state == ContractState.Uninitialized) return \"Uninitialized\";\n\t\tif (state == ContractState.LimitBuy) return \"LimitBuy\";\n\t\tif (state == ContractState.TrailingStop) return \"TrailingStop\";\n\t\tif (state == ContractState.Inactive) return \"Inactive\";\n\t\treturn \"Unknown\"; // fallback in case of an unexpected state\n\t}\n}\n"
    },
    "contracts/TrailMixManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nerror NotContractOwner(); // Error for when the caller is not the contract owner\r\n\r\nimport { TrailMix } from \"./TrailMix.sol\"; // Import TrailMix contract\r\nimport { ITrailMix } from \"./ITrailMix.sol\"; // Import ITrailMix interface\r\n\r\ncontract TrailMixManager is ReentrancyGuard {\r\n\t//array storing all active strategies\r\n\taddress[] public activeStrategies;\r\n\t// mapping to store index of strategy in activeStrategies array\r\n\tmapping(address => uint256) private strategyIndex;\r\n\r\n\t//mapping for quick lookup for if a strategy is active\r\n\tmapping(address => bool) public isActiveStrategy;\r\n\r\n\t// Mapping from user address to array of deployed TrailMix contract addresses\r\n\tmapping(address => address[]) public userContracts;\r\n\r\n\taddress private gelatoExecutor; //only address authorized to call performUpkeep\r\n\r\n\taddress private managerDeployer; //address authorized to set gelato executor\r\n\r\n\tmodifier onlyAuthorized() {\r\n\t\trequire(\r\n\t\t\tmsg.sender == address(this) ||\r\n\t\t\t\tmsg.sender == address(gelatoExecutor),\r\n\t\t\t\"Not authorized\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Event to emit when a new TrailMix contract is deployed\r\n\tevent ContractDeployed(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed contractAddress,\r\n\t\taddress indexed token,\r\n\t\tuint256 trailAmount,\r\n\t\tuint256 timestamp\r\n\t);\r\n\r\n\tevent FundsDeposited(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed strategy,\r\n\t\tuint256 depositPrice,\r\n\t\tuint256 amount,\r\n\t\taddress token,\r\n\t\tuint256 timestamp,\r\n\t\tuint256 trailAmount\r\n\t);\r\n\tevent FundsWithdrawn(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed strategy,\r\n\t\tuint256 amount,\r\n\t\taddress token,\r\n\t\tuint256 timestamp,\r\n\t\tuint256 trailAmount\r\n\t);\r\n\tevent ThresholdUpdated(\r\n\t\taddress indexed strategy,\r\n\t\tuint256 oldThreshold,\r\n\t\tuint256 newThreshold,\r\n\t\tuint256 timestamp\r\n\t);\r\n\tevent SwapExecuted(\r\n\t\taddress indexed strategy,\r\n\t\taddress indexed creator,\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOut,\r\n\t\taddress tokenIn,\r\n\t\taddress tokenOut,\r\n\t\tuint256 timestamp\r\n\t);\r\n\r\n\tconstructor() {\r\n\t\tmanagerDeployer = msg.sender;\r\n\t}\r\n\r\n\t// Function to deploy a new TrailMix contract\r\n\tfunction deployTrailMix(\r\n\t\taddress _erc20Token,\r\n\t\taddress _stablecoin,\r\n\t\taddress _uniswapRouter,\r\n\t\taddress _uniswapPool,\r\n\t\taddress _uniswapOracle,\r\n\t\tuint256 _trailAmount,\r\n\t\tuint256 _granularity,\r\n\t\tuint24 _poolFee,\r\n\t\taddress _ethUsdPriceFeed,\r\n\t\tbool _wethPair\r\n\t) public {\r\n\t\t// Deploy the TrailMix contract\r\n\t\tTrailMix newTrailMix = new TrailMix(\r\n\t\t\taddress(this), // The TrailMixManager contract address\r\n\t\t\tmsg.sender, // The user becomes the creator of the TrailMix contract\r\n\t\t\t_erc20Token,\r\n\t\t\t_stablecoin,\r\n\t\t\t_uniswapRouter,\r\n\t\t\t_uniswapPool,\r\n\t\t\t_uniswapOracle,\r\n\t\t\t_trailAmount,\r\n\t\t\t_granularity,\r\n\t\t\t_poolFee,\r\n\t\t\t_ethUsdPriceFeed,\r\n\t\t\t_wethPair\r\n\t\t);\r\n\r\n\t\t// Store the contract address in the userContracts mapping\r\n\t\tuserContracts[msg.sender].push(address(newTrailMix));\r\n\r\n\t\t// Emit an event for the deployment\r\n\t\temit ContractDeployed(\r\n\t\t\tmsg.sender,\r\n\t\t\taddress(newTrailMix),\r\n\t\t\t_erc20Token,\r\n\t\t\t_trailAmount,\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t}\r\n\r\n\tfunction deposit(\r\n\t\taddress _strategy,\r\n\t\tuint256 _amount,\r\n\t\tuint256 _tslThreshold\r\n\t) public {\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\r\n\t\t// Get the ERC20 token address from the TrailMix contract\r\n\t\taddress erc20TokenAddress = ITrailMix(_strategy).getERC20TokenAddress();\r\n\t\t//transfer funds from user to the manager contract\r\n\t\tIERC20(erc20TokenAddress).transferFrom(\r\n\t\t\tmsg.sender,\r\n\t\t\taddress(this),\r\n\t\t\t_amount\r\n\t\t);\r\n\r\n\t\t// approve strategy to spend the funds and call deposit\r\n\t\tIERC20(erc20TokenAddress).approve(_strategy, _amount);\r\n\t\tITrailMix(_strategy).deposit(_amount, _tslThreshold);\r\n\r\n\t\t//if contract is not in the active array then add it to the active array\r\n\t\tif (!isActiveStrategy[address(_strategy)]) {\r\n\t\t\tactiveStrategies.push(address(_strategy));\r\n\t\t\tisActiveStrategy[address(_strategy)] = true;\r\n\t\t\tstrategyIndex[address(_strategy)] = activeStrategies.length - 1;\r\n\t\t}\r\n\r\n\t\t// Emit an event for the deposit\r\n\t\temit FundsDeposited(\r\n\t\t\tmsg.sender,\r\n\t\t\t_strategy,\r\n\t\t\tITrailMix(_strategy).getExactPrice(erc20TokenAddress),\r\n\t\t\t_amount,\r\n\t\t\tITrailMix(_strategy).getERC20TokenAddress(),\r\n\t\t\tblock.timestamp,\r\n\t\t\tITrailMix(_strategy).getTrailAmount()\r\n\t\t);\r\n\t}\r\n\r\n\tfunction withdraw(address _strategy, address _token) public nonReentrant {\r\n\t\t// Withdraw the user's funds from the TrailMix contract\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\r\n\t\tuint256 amount;\r\n\t\t//fetch amount to be withdrawn\r\n\t\tif (_token == ITrailMix(_strategy).getERC20TokenAddress()) {\r\n\t\t\tamount = ITrailMix(_strategy).getERC20Balance();\r\n\t\t} else {\r\n\t\t\tamount = ITrailMix(_strategy).getStablecoinBalance();\r\n\t\t}\r\n\r\n\t\tITrailMix(_strategy).withdraw(_token);\r\n\r\n\t\tif (isActiveStrategy[_strategy]) {\r\n\t\t\tremoveStrategy(_strategy);\r\n\t\t}\r\n\r\n\t\temit FundsWithdrawn(\r\n\t\t\tmsg.sender,\r\n\t\t\t_strategy,\r\n\t\t\tamount,\r\n\t\t\t_token,\r\n\t\t\tblock.timestamp,\r\n\t\t\tITrailMix(_strategy).getTrailAmount()\r\n\t\t);\r\n\t}\r\n\r\n\tfunction toggleSlippageProtection(address _strategy) public {\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\t\tITrailMix(_strategy).toggleSlippageProtection();\r\n\t}\r\n\r\n\t// Remove a strategy\r\n\tfunction removeStrategy(address strategy) private {\r\n\t\trequire(strategy != address(0), \"Invalid address\");\r\n\r\n\t\tisActiveStrategy[strategy] = false;\r\n\r\n\t\t// Move the last element into the place to delete\r\n\t\tuint256 index = strategyIndex[strategy];\r\n\t\taddress lastStrategy = activeStrategies[activeStrategies.length - 1];\r\n\t\tactiveStrategies[index] = lastStrategy;\r\n\t\tstrategyIndex[lastStrategy] = index;\r\n\t\tactiveStrategies.pop();\r\n\r\n\t\t// Clean up\r\n\t\tdelete strategyIndex[strategy];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Checks if upkeep is needed based on TSL conditions.COMPUTED OFF-CHAIN\r\n\t * @dev Part of the Gelato automation\r\n\t * @return canExec Boolean flag indicating if upkeep is needed.\r\n\t * @return execPayload Encoded data on what action to perform during upkeep.\r\n\t */\r\n\tfunction checker()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool canExec, bytes memory execPayload)\r\n\t{\r\n\t\tbool updateNeeded = false;\r\n\t\tbytes memory updateData;\r\n\t\tfor (uint256 i = 0; i < activeStrategies.length; i++) {\r\n\t\t\t(bool buy, bool sell, bool update, uint256 newThreshold) = ITrailMix(\r\n\t\t\t\tactiveStrategies[i]\r\n\t\t\t).checkUpkeepNeeded();\r\n\r\n\t\t\tif (sell) {\r\n\t\t\t\t// Prioritize swap action if needed\r\n\t\t\t\treturn (\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\tthis.performUpkeep.selector,\r\n\t\t\t\t\t\tactiveStrategies[i],\r\n\t\t\t\t\t\tsell,\r\n\t\t\t\t\t\tupdate,\r\n\t\t\t\t\t\tnewThreshold\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t} else if (buy){\r\n\t\t\t\t// Prioritize swap action if needed\r\n\t\t\t\treturn (\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\tthis.performUpkeep.selector,\r\n\t\t\t\t\t\tactiveStrategies[i],\r\n\t\t\t\t\t\tbuy,\r\n\t\t\t\t\t\tsell,\r\n\t\t\t\t\t\tupdate,\r\n\t\t\t\t\t\tnewThreshold\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if (update) {\r\n\t\t\t\t// If no swap needed, check for threshold update\r\n\t\t\t\t// Note: This approach only encodes action for the first strategy needing an action.\r\n\t\t\t\tif (!updateNeeded) {\r\n\t\t\t\t\tupdateNeeded = true;\r\n\t\t\t\t\tupdateData = abi.encodeWithSelector(\r\n\t\t\t\t\t\tthis.performUpkeep.selector,\r\n\t\t\t\t\t\tactiveStrategies[i],\r\n\t\t\t\t\t\tbuy,\r\n\t\t\t\t\t\tsell,\r\n\t\t\t\t\t\tupdate,\r\n\t\t\t\t\t\tnewThreshold\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (updateNeeded) {\r\n\t\t\treturn (true, updateData);\r\n\t\t}\r\n\r\n\t\treturn (false, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Performs the upkeep of updating the stop loss threshold or triggering a sell.\r\n\t * @dev Part of the gelato automation.\r\n\t */\r\n\tfunction performUpkeep(\r\n\t\taddress strategy,\r\n\t\tbool buy,\r\n\t\tbool sell,\r\n\t\tbool updateThreshold,\r\n\t\tuint256 newThreshold\r\n\t) external onlyAuthorized {\r\n\t\t_performUpkeep(strategy, buy, sell, updateThreshold, newThreshold);\r\n\t}\r\n\r\n\tfunction _performUpkeep(\r\n\t\taddress strategy,\r\n\t\tbool buy,\r\n\t\tbool sell,\r\n\t\tbool updateThreshold,\r\n\t\tuint256 newThreshold\r\n\t) private {\r\n\t\t// Implement logic to perform TSL (e.g., swap to stablecoin) when conditions are met\r\n\r\n\t\tif (sell) {\r\n\t\t\t//store balance before the sell occurs\r\n\t\t\tuint256 s_erc20Balance = ITrailMix(strategy).getERC20Balance();\r\n\r\n\t\t\t//call trigger function to sell on uniswap\r\n\t\t\tITrailMix(strategy).executeTSL();\r\n\r\n\t\t\t//emit swap event\r\n\t\t\temit SwapExecuted(\r\n\t\t\t\tstrategy,\r\n\t\t\t\tITrailMix(strategy).getCreator(),\r\n\t\t\t\ts_erc20Balance,\r\n\t\t\t\tITrailMix(strategy).getStablecoinBalance(),\r\n\t\t\t\tITrailMix(strategy).getERC20TokenAddress(),\r\n\t\t\t\tITrailMix(strategy).getStablecoinAddress(),\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t} else if (buy){\r\n\t\t\tuint256 s_stablecoinBalance = ITrailMix(strategy).getStablecoinBalance();\r\n\r\n\t\t\tITrailMix(strategy).executeLimitBuy();\r\n\r\n\t\t\t//emit swap event\r\n\t\t\temit SwapExecuted(\r\n\t\t\t\tstrategy,\r\n\t\t\t\tITrailMix(strategy).getCreator(),\r\n\t\t\t\ts_stablecoinBalance,\r\n\t\t\t\tITrailMix(strategy).getERC20Balance(),\r\n\t\t\t\tITrailMix(strategy).getStablecoinAddress(),\r\n\t\t\t\tITrailMix(strategy).getERC20TokenAddress(),\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t}\r\n\t\t\r\n\t\telse if (updateThreshold) {\r\n\t\t\tuint256 oldThreshold = ITrailMix(strategy).getTSLThreshold();\r\n\r\n\t\t\t//call updateThreshold function to update the threshold\r\n\t\t\tITrailMix(strategy).updateTSLThreshold(newThreshold);\r\n\t\t\t//emit event for threshold update\r\n\t\t\temit ThresholdUpdated(\r\n\t\t\t\tstrategy,\r\n\t\t\t\toldThreshold,\r\n\t\t\t\tnewThreshold,\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Function to get all contracts deployed by a user\r\n\tfunction getUserContracts(\r\n\t\taddress user\r\n\t) public view returns (address[] memory) {\r\n\t\treturn userContracts[user];\r\n\t}\r\n\r\n\tfunction setGelatoExecutor(address _executor) public {\r\n\t\t// Logic to set the Gelato executor address\r\n\t\trequire(msg.sender == managerDeployer, \"Not authorized\");\r\n\t\tgelatoExecutor = _executor;\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}